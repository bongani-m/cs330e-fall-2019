•	 build CrossJoin
CrossJoin (r, s): 
CrossJoin combines 
the first row of r with all rows of s, 
the second row of r with all rows of s, 
....
Cross-Join(r,s)
Note: dict constructor receives two dictionaries and returns one dictionary that results from combining first with the unpacking of the second.
e.g., 
d1 = {}
d2 = {}
d3 = dict(d1, **d2)
Note:
(1) d = {1: 'one', 2: 'two'} is possible, but, obviously, dict(1='one' ...) is not.
(2) when applying dict on d1 and d2 where both have two identical key values, the value of d2 is taken.
(3) When using dict constructor with dictionaries that has integer keys, we receive an error.
# error
>>> d1 = {1 : "one", 2 : "two"}
>>> d2 = {3 : "Three", 4 : "Four"}
>>> d3 = dict(d1, **d2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: keyword arguments must be strings

# no error - replace integers with strings.
>>> d1 = {"1" : "one", "2" : "two"}
>>> d2 = {"3" : "Three", "4" : "Four"}
>>> dict(d1, **d2)
{'3': 'Three', '4': 'Four', '1': 'one', '2': 'two'}
>>>


•	build ThetaJoin
ThetaJoin joins corresponding rows given certain conditions.
E.g., Given two relations:
r with 3 rows
s with 4 rows
lambda u, v : u["A"] == v["C"]
u: a row from the first relations r
v: a row from the second relation v
u["A"]: the value of the attribute "A" in u
v["C"]: the value of the attribute "C" in v

•	build NaturalJoin
NaturalJoin marries rows from two relations when columns of common attributes have same values.
r = [{"A" : 1, "B" : 4, "C" : 7},
       {"A" : 2, "B" : 5, "C" : 8},
       {"A" : 3, "B" : 6, "C" : 9}] # attributes A, B and C

s = [{"A" : 2, "B" : 4, "D" : 7}, # attributes A, B and D
       {"A" : 3, "B" : 5, "D" : 5},
       {"A" :  3, "B" : 6, "D" : 6},
       {"A" :  4, "B" : 7, "D" : 6}]
NaturalJoin(r, s) = [{'A' :  3, 'B' : 6, 'C' : 9, 'D' : 6}]
 # r and share the attributes "A" and "B", therefore we will marry the two rows that has the same values
# for these two attributes. row #3 of r and row # 3 of s.
naturaljoin(r,s): marry rows from two relations when col of commnon attributes have the same value.
Note:
-----
(1) in case of no common attributes between r and s, naturaljoin will do cross join
(2) in case of common attributes but no common values, naturaljoin will do nothing.
(3) in case of common attributes with common values, naturaljoin will return the common values. 
------------------------------
Note:
def bp (u, v) :
    return not any(u[k] != v[k] *for* k in u *if* k in v) # can be replaced with "retrun all(u[k] == v[k] ...)"

This predicate return true when two rows, u and v, have equal values for the same attributes, 
False, otherwise.
Note that in case of the two rows have completely different attributes, bp will return true.

This predicate will return true in two cases. First when there are no common attributes between the two input dictionaries or when all the common attributes have the same value.
It will return false if there is at least one common attribute with different value.

•	RegExp: is a special text string for describing a search pattern.

"^b" splits if the string starts with a "b.

"^a" splits if the string starts with an "a" 

Note: 
s = "b ab\naab 123"
r = re.compile("^a", re.M)                          # multiline
assert str(type(r)) == "<class '_sre.SRE_Pattern'>"
a = r.split(s)
•	.compile: compiles a regular expression pattern into a regular expression object. 
•	re.M: multiline. (^ and $ will match at the beginning and at the end of each line 
        and not just at the beginning and the end of the string)
•	_sre.SRE_Pattern: regular pattern object.

Compile takes a pattern, "^a", and a multiline, "re.M", and saves the result back in r, 
r is now will be run on a multiline string looking for any string starts with an "a".  
r.split(s) will parse through s looking for a line that starts with an "a"  in a multiline string, 
if it finds one, it will split into two parts, what's before the a and what's after it.  
Note: if s = "b ab\nbbb 123", then the result stored in a will be ['b ab\nbbb 123'].

"3$" splits if the string ends with a "3"
           	
"." splits if it finds any character except for a new line
 
"\d" splits if it finds any digit. 

"\D" splits it finds any non-digit. 

"\w" splits if it finds any alphanumeric (except for a new line and spaces). 

In the provided string:
 
result = re.split("\w", "b ab\naab 123")
# result == ['', ' ', '', '\n', '', '', ' ', '', '', '']

You go through the string a character at a time and whenever you find any alphanumeric, you split into two parts: what's before the current position in your string and what's after it.
 
Starting from the beginning of the string:
For b, what's before it is an empty string, '', and what's after it is ' ab\naab 123' -- output the first empty string, ''.
For the space, ' ', we do not split.
For a, what's before it is a space, '  ', and what's after it is 'b\naab 123" -- output the space, ' '.
For b, what's before it is an empty string, '', and what's after it is ' \naab 123' -- output the empty string, ''.
For the newline, '\n', we do not split. 
For a, what's before it is '\n' -- -- output the newline, '\n'.
Continue consuming the string in this pattern.

"\W" splits whenever it finds any non-alphanumeric.

s = "b ab\naab 123"
m = re.search("(a*)b([^a]*)(a*)b", s)             # * is zero or more
assert str(type(m)) == "<class '_sre.SRE_Match'>"
assert m.group(0) == "b ab"
assert m.group(1) == ""
assert m.group(2) == " "
assert m.group(3) == "a"
store the string "b ab\naab 123" in the variable s, run search command from re library. search takes a pattern, "(a*)b([^a]*)(a*)b", and a string, and does the following: 
it goes through the string and try to search for the pattern. The result will be 4 groups: group(0) - group(3), the contents of these groups are as follows:
Note: The match will consider each line in the target string separately.
m.group(0): will contain the matches for the entire expression "(a*)b([^a]*)(a*)b". result: "b ab"
m.group(1): will contain the matches for "(a*)". result: ""
m.group(2): will contain the matches for "([^a]*)". result:" "
m.group(3): will contain the matches for "(a*)". result:"a"

[^ ]: ^ means NOT.
